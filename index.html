<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ClipShortener — Video Splitter</title>
  <style>
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#0b0f17;color:#e5e7eb}
    .wrap{width:min(900px,92vw);margin:0 auto;padding:22px 0}
    .card{border:1px solid #243042;border-radius:16px;padding:16px;background:rgba(255,255,255,.03)}
    h1{margin:0 0 6px;font-size:26px}
    p{margin:8px 0;color:#9ca3af;line-height:1.4}
    input,select,button{width:100%;margin-top:12px;padding:12px;border-radius:12px;border:1px solid #243042;background:rgba(0,0,0,.25);color:#e5e7eb;font-size:16px}
    button{background:#e5e7eb;color:#0b0f17;font-weight:800;cursor:pointer;border:none}
    button:disabled{opacity:.6;cursor:not-allowed}
    .row{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:860px){.row{grid-template-columns:1fr 1fr;align-items:start}}
    .box{margin-top:12px;padding:12px;border:1px dashed #243042;border-radius:12px;color:#9ca3af;font-size:13px}
    .log{white-space:pre-wrap;background:rgba(0,0,0,.25);border:1px solid #243042;border-radius:12px;padding:10px;margin-top:12px;color:#9ca3af;font-size:13px}
    .list a{display:block;margin-top:10px;padding:10px;border:1px solid #243042;border-radius:12px;color:#e5e7eb;text-decoration:none;background:rgba(0,0,0,.22)}
    .tiny{font-size:12px;color:#9ca3af}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>ClipShortener</h1>
      <p><b>Video-only</b>: upload a video → split into <b>5-minute clips</b> → download the clips.</p>

      <div class="row">
        <div>
          <label class="tiny">1) Upload video file (MP4 recommended)</label>
          <input id="file" type="file" accept="video/*" />

          <label class="tiny">2) Clip length (fixed for v1)</label>
          <label class="tiny" style="display:block;margin-top:10px">3) Cut mode</label>
<select id="mode">
<label class="tiny" style="display:block;margin-top:10px">4) Quality</label>
<select id="quality">
  <option value="social">Social (smallest)</option>
  <option value="balanced" selected>Balanced (recommended)</option>
  <option value="high">High (best quality)</option>
</select>
  <option value="fast" selected>Fast (recommended)</option>
  <option value="accurate">Accurate (slower, more reliable)</option>
</select>
  <option value="15">15 seconds</option>
  <option value="30">30 seconds</option>
  <option value="60">60 seconds</option>
  <option value="300" selected>5 minutes</option>
  <option value="900">15 minutes (max)</option>
          </select>

          <button id="start" disabled>Split video into clips</button>

          <div class="box">
            Notes (kept simple):
            <ul style="margin:8px 0 0 18px">
              <li>Processing happens on the user’s device (free).</li>
              <li>First load downloads the splitter engine once (can take a moment).</li>
              <li>Clips may cut slightly off exact seconds if the video isn’t keyframe-aligned (we can improve later).</li>
            </ul>
          </div>

          <div id="status" class="log">Status: waiting for a video file.</div>
        </div>

        <div>
          <label class="tiny">3) Download your clips</label>
          <div id="downloads" class="list"></div>
<button id="downloadZip" disabled style="margin-top:12px">Download all as .zip</button>
          <div class="box">
            If you see no links after processing, tell me what your Status box says and I’ll fix it.
          </div>
        </div>
      </div>

      <p class="tiny" style="margin-top:12px">
        Monetisation later: public limits + Pro features. You will keep unlimited creator access.
      </p>
    </div>
  </div>

  <!-- ffmpeg.wasm (browser video processing) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script  const downloadZipBtn = document.getElementById("downloadZip");
let lastOutputs = []; // { name, data }type="module"// Remove old outputs so downloads don’t mix runs
for (const f of ffmpeg.FS("readdir", "/")) {
  if (f.startsWith("out_") && f.endsWith(".mp4")) {
    try { ffmpeg.FS("unlink", f); } catch {}
  }
}>
    import { createFFmpeg, fetchFile } from "https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js";

    const fileEl = document.getElementById("file");
    const startBtn = document.getElementById("start");
    const statusEl = document.getElementById("status");
    const downloadsEl = document.getElementById("downloads");

    const DEFAULT_SECONDS = 300; // 5 minutes default
    const MAX_SEGMENT_SECONDS = 900; // hard max 15 min (policy)

    let selectedFile = null;

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function clearDownloads() {
  downloadsEl.innerHTML = "";
  lastOutputs = [];
  if (downloadZipBtn) downloadZipBtn.disabled = true;
    }

    function addDownloadLink(filename, data) {
      const blob = new Blob([data.buffer], { type: "video/mp4" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.textContent = `Download ${filename}`;
      downloadsEl.appendChild(a);
    }

    fileEl.addEventListener("change", () => {
      selectedFile = fileEl.files?.[0] || null;
      clearDownloads();

      if (!selectedFile) {
        startBtn.disabled = true;
        setStatus("Status: waiting for a video file.");
        return;
      }

      startBtn.disabled = false;
      setStatus(`Status: ready. Selected: ${selectedFile.name} (${Math.round(selectedFile.size/1024/1024)} MB)`);
    });

    startBtn.addEventListener("click", async () => {
      if (!selectedFile) return;

      clearDownloads();
      startBtn.disabled = true;

    const lengthEl = document.getElementById("length");
const chosen = parseInt(lengthEl.value, 10) || DEFAULT_SECONDS;
const segmentTime = Math.min(chosen, MAX_SEGMENT_SECONDS); // hard cap at 15 minutes

      setStatus("Status: loading video engine (first time may take a moment)...");
      const ffmpeg = createFFmpeg({
        log: false,
        corePath: "https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js"
      });

      try {
        if (!ffmpeg.isLoaded()) await ffmpeg.load();
      } catch (e) {
        setStatus("Error loading engine. Try reloading the page and using a smaller video.");
        startBtn.disabled = false;
        return;
      }

      try {
        setStatus("Status: reading video file...");
        const inputName = "input.mp4";
        ffmpeg.FS("writeFile", inputName, await fetchFile(selectedFile));

        setStatus("Status: splitting video into 5-minute clips...");
        // Fast path: stream copy (no re-encode). Some sources may not cut exactly on the second.
        // Output: out_000.mp4, out_001.mp4, ...
        const modeEl = document.getElementById("mode");
const mode = modeEl?.value || "fast";

    const qualityEl = document.getElementById("quality");
const quality = qualityEl?.value || "balanced";

let crf = 28;       // lower = better quality, larger files
let scale = "1280:-2"; // 720p-ish by default (keeps aspect ratio)
let audioBitrate = "96k";

if (quality === "social") {
  crf = 30;
  scale = "854:-2";      // ~480p
  audioBitrate = "64k";
} else if (quality === "high") {
  crf = 24;
  scale = "1920:-2";     // up to 1080p (if input allows)
  audioBitrate = "128k";
    }

if (mode === "fast") {
  // Very fast (no re-encode). May cut slightly off exact seconds on some files.
  await ffmpeg.run(
    "-i", inputName,
    "-c", "copy",
    "-map", "0",
    "-f", "segment",
    "-segment_time", String(segmentTime),
    "-reset_timestamps", "1",
    "out_%03d.mp4"
  );
} else {
  // Accurate (re-encode). Slower, but cuts more reliably at the chosen length.
  // Keeps files reasonably small for social media.
  

        setStatus("Status: preparing downloads...");
        const files = ffmpeg.FS("readdir", "/").filter(f => f.startsWith("out_") && f.endsWith(".mp4"));

        if (!files.length) {
          setStatus("No clips were generated. Try a different video format (MP4) or a smaller file.");
          startBtn.disabled = false;
          return;
        }

        // Create download links
        // Create nicer base name
const baseName = (selectedFile.name || "video").replace(/\.[^/.]+$/, "").replace(/[^a-z0-9-_ ]/gi,await ffmpeg.run(
  "-i", inputName,
  "-map", "0:v:0?",
  "-map", "0:a:0?",
  "-vf", `scale=${scale}`,
  "-c:v", "libx264",
  "-preset", "veryfast",
  "-crf", String(crf),
  "-c:a", "aac",
  "-b:a", audioBitrate,
  "-movflags", "+faststart",
  "-f", "segment",
  "-segment_time", String(segmentTime),
  "-reset_timestamps", "1",
  "out_%03d.mp4"
); "").trim().replace(/\s+/g, "_");

for (let i = 0; i < files.length; i++) {
  const f = files[i];
  const data = ffmpeg.FS("readFile", f);

  const niceName = `${baseName}_clip_${String(i+1).padStart(2,"0")}.mp4`;
  lastOutputs.push({ name: niceName, data });

  addDownloadLink(niceName, data);
}

if (downloadZipBtn) downloadZipBtn.disabled = false;

        setStatus(`Done. Generated ${files.length} clips.`);
      } catch (e) {
        setStatus("Error during splitting. Try an MP4 video that is smaller/shorter. If it still fails, tell me this message and your video type.");
      } finally {
        startBtn.disabled = false; downloadZipBtn?.addEventListener("click", async () => {
  if (!lastOutputs.length) return;

  setStatus("Status: creating ZIP (this can take a moment)...");
  downloadZipBtn.disabled = true;

  try {
    const zip = new window.JSZip();
    for (const f of lastOutputs) {
      zip.file(f.name, f.data);
    }
    const blob = await zip.generateAsync({ type: "blob" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "clipshortener_clips.zip";
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();

    setStatus(`Done. ZIP downloaded with ${lastOutputs.length} clips.`);
  } catch (e) {
    setStatus("ZIP failed. Try downloading clips individually or use a shorter video.");
  } finally {
    downloadZipBtn.disabled = false;
  }
});
      }
    });
  </script>
</body>
  </html>
